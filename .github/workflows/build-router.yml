name: docker-build

on:
  workflow_dispatch:
    inputs:
      docker_tag:
        description: Docker image tag to publish
        default: latest
        required: true
      version_feature_set:
        description: Value for the VERSION_FEATURE_SET build arg
        default: v1
        required: true
      extra_features:
        description: Additional cargo feature flags (empty string keeps default)
        default: ""
        required: false
      runner:
        description: GitHub-hosted runner label (pick a larger runner as needed)
        default: ubuntu-latest
        required: true
      router_image:
        description: Docker Hub image name for the router (fallback to repository variables)
        default: "mithras-hyper-router"
        required: false
      scheduler_image:
        description: Docker Hub image name for the scheduler (fallback to repository variables)
        default: "mithras-hyper-scheduler"
        required: false
      drainer_image:
        description: Docker Hub image name for the drainer (fallback to repository variables)
        default: "mithras-hyper-drainer"
        required: false
      docker_namespace:
        description: Docker Hub namespace/organization to prepend when image names omit it
        default: "lucasdpxsol"
        required: false
  push:
    tags:
      - "v*"
      - "release-*"
  release:
    types:
      - published

jobs:
  registry_access:
    name: Validate Docker registry credentials
    runs-on: ${{ inputs.runner || 'ubuntu-latest' }}
    outputs:
      router_image: ${{ steps.resolve.outputs.router_image }}
      scheduler_image: ${{ steps.resolve.outputs.scheduler_image }}
      drainer_image: ${{ steps.resolve.outputs.drainer_image }}
    steps:
      - name: Ensure Docker Hub secrets present
        shell: bash
        run: |
          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ] || [ -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "::error::DOCKERHUB_USERNAME and/or DOCKERHUB_TOKEN secrets are missing."
            exit 1
          fi

      - name: Resolve image names
        id: resolve
        shell: bash
        env:
          INPUT_ROUTER_IMAGE: ${{ inputs.router_image }}
          INPUT_SCHEDULER_IMAGE: ${{ inputs.scheduler_image }}
          INPUT_DRAINER_IMAGE: ${{ inputs.drainer_image }}
          VAR_ROUTER_IMAGE: ${{ vars.ROUTER_IMAGE_NAME }}
          VAR_SCHEDULER_IMAGE: ${{ vars.SCHEDULER_IMAGE_NAME }}
          VAR_DRAINER_IMAGE: ${{ vars.DRAINER_IMAGE_NAME }}
          VAR_IMAGE: ${{ vars.IMAGE_NAME }}
          NAMESPACE: ${{ inputs.docker_namespace || vars.DOCKER_NAMESPACE || 'lucasdpxsol' }}
        run: |
          resolve_image() {
            local candidate="$1"
            local namespace="$2"
            if [ -n "$candidate" ]; then
              if [[ "$candidate" == */* ]]; then
                printf '%s' "$candidate"
              else
                printf '%s/%s' "$namespace" "$candidate"
              fi
              return 0
            fi
            return 1
          }

          pick_image() {
            local explicit="$1"
            local scoped_var="$2"
            local shared_var="$3"
            local default_repo="$4"
            local namespace="$5"
            local value=""

            value=$(resolve_image "$explicit" "$namespace") && { printf '%s' "$value"; return; }
            value=$(resolve_image "$scoped_var" "$namespace") && { printf '%s' "$value"; return; }
            value=$(resolve_image "$shared_var" "$namespace") && { printf '%s' "$value"; return; }
            printf '%s/%s' "$namespace" "$default_repo"
          }

          ROUTER_IMAGE=$(pick_image "$INPUT_ROUTER_IMAGE" "$VAR_ROUTER_IMAGE" "$VAR_IMAGE" "mithras-hyper-router" "$NAMESPACE")
          SCHEDULER_IMAGE=$(pick_image "$INPUT_SCHEDULER_IMAGE" "$VAR_SCHEDULER_IMAGE" "$VAR_IMAGE" "mithras-hyper-scheduler" "$NAMESPACE")
          DRAINER_IMAGE=$(pick_image "$INPUT_DRAINER_IMAGE" "$VAR_DRAINER_IMAGE" "$VAR_IMAGE" "mithras-hyper-drainer" "$NAMESPACE")

          printf 'ROUTER_IMAGE=%s\n' "$ROUTER_IMAGE" >> "$GITHUB_ENV"
          printf 'SCHEDULER_IMAGE=%s\n' "$SCHEDULER_IMAGE" >> "$GITHUB_ENV"
          printf 'DRAINER_IMAGE=%s\n' "$DRAINER_IMAGE" >> "$GITHUB_ENV"

          printf 'router_image=%s\n' "$ROUTER_IMAGE" >> "$GITHUB_OUTPUT"
          printf 'scheduler_image=%s\n' "$SCHEDULER_IMAGE" >> "$GITHUB_OUTPUT"
          printf 'drainer_image=%s\n' "$DRAINER_IMAGE" >> "$GITHUB_OUTPUT"

          echo "Resolved images:"
          echo "  Router   -> $ROUTER_IMAGE"
          echo "  Scheduler-> $SCHEDULER_IMAGE"
          echo "  Drainer  -> $DRAINER_IMAGE"

      - name: Validate image name format
        shell: bash
        run: |
          check_image() {
            local name="$1"
            local label="$2"
            if [ -z "$name" ]; then
              echo "::error::$label image name resolved to an empty value."
              exit 1
            fi
            if [[ "$name" != */* ]]; then
              echo "::error::$label image '$name' must include a registry namespace (for Docker Hub, use <username>/<repository>)."
              exit 1
            fi
          }
          check_image "$ROUTER_IMAGE" "Router"
          check_image "$SCHEDULER_IMAGE" "Scheduler"
          check_image "$DRAINER_IMAGE" "Drainer"

      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Confirm push scope
        shell: bash
        env:
          DOCKER_CLI_EXPERIMENTAL: enabled
        run: |
          for image in "$ROUTER_IMAGE" "$SCHEDULER_IMAGE" "$DRAINER_IMAGE"; do
            repo="${image%%:*}"
            echo "Verifying push permissions for $repo"
            if ! docker buildx imagetools inspect "$repo:latest" >/dev/null 2>&1; then
              echo "::warning::Inspect failed for $repo:latest (this is expected if the repository is new or private)."
            fi
          done

  router:
    name: Build router image (${{ inputs.docker_tag || (github.event_name == 'release' && github.event.release.tag_name) || github.ref_name }})
    runs-on: ${{ inputs.runner || 'ubuntu-latest' }}
    needs: registry_access
    env:
      DOCKER_IMAGE: ${{ needs.registry_access.outputs.router_image }}
      DOCKER_TAG: ${{ inputs.docker_tag || (github.event_name == 'release' && github.event.release.tag_name) || github.ref_name }}
      VERSION_FEATURE_SET: ${{ inputs.version_feature_set || 'v1' }}
      EXTRA_FEATURES: ${{ inputs.extra_features || '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push router image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
          build-args: |
            BINARY=router
            VERSION_FEATURE_SET=${{ env.VERSION_FEATURE_SET }}
            EXTRA_FEATURES=${{ env.EXTRA_FEATURES }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache,mode=max
          provenance: false

  scheduler:
    name: Build scheduler image (${{ inputs.docker_tag || (github.event_name == 'release' && github.event.release.tag_name) || github.ref_name }} - ${{ matrix.scheduler_flow }})
    runs-on: ${{ inputs.runner || 'ubuntu-latest' }}
    strategy:
      matrix:
        scheduler_flow: [consumer, producer]
    needs: registry_access
    env:
      DOCKER_IMAGE: ${{ needs.registry_access.outputs.scheduler_image }}
      DOCKER_TAG: ${{ inputs.docker_tag || (github.event_name == 'release' && github.event.release.tag_name) || github.ref_name }}
      VERSION_FEATURE_SET: ${{ inputs.version_feature_set || 'v1' }}
      EXTRA_FEATURES: ${{ inputs.extra_features || '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push scheduler image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}-${{ matrix.scheduler_flow }}
          build-args: |
            BINARY=scheduler
            SCHEDULER_FLOW=${{ matrix.scheduler_flow }}
            VERSION_FEATURE_SET=${{ env.VERSION_FEATURE_SET }}
            EXTRA_FEATURES=${{ env.EXTRA_FEATURES }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache,mode=max
          provenance: false

  drainer:
    name: Build drainer image (${{ inputs.docker_tag || (github.event_name == 'release' && github.event.release.tag_name) || github.ref_name }})
    runs-on: ${{ inputs.runner || 'ubuntu-latest' }}
    needs: registry_access
    env:
      DOCKER_IMAGE: ${{ needs.registry_access.outputs.drainer_image }}
      DOCKER_TAG: ${{ inputs.docker_tag || (github.event_name == 'release' && github.event.release.tag_name) || github.ref_name }}
      VERSION_FEATURE_SET: ${{ inputs.version_feature_set || 'v1' }}
      EXTRA_FEATURES: ${{ inputs.extra_features || '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push drainer image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
          build-args: |
            BINARY=drainer
            VERSION_FEATURE_SET=${{ env.VERSION_FEATURE_SET }}
            EXTRA_FEATURES=${{ env.EXTRA_FEATURES }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache,mode=max
          provenance: false
